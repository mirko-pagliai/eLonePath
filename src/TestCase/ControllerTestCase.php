<?php
declare(strict_types=1);

namespace eLonePath\TestCase;

use eLonePath\Controller\Controller;
use PHPUnit\Framework\TestCase;
use RuntimeException;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;

/**
 * Abstract base class for controller testing.
 *
 * Provides utilities to execute controller actions via route matching and assert on the resulting HTTP responses. This
 *  class simulates the request/response cycle without requiring a full kernel setup.
 */
abstract class ControllerTestCase extends TestCase
{
    protected static RouteCollection $routes;

    /**
     * The HTTP response generated by the last executed action.
     *
     * This property is populated by `executeAction()` and can be `null` if no action has been executed yet in the
     * current test method.
     *
     * @var \Symfony\Component\HttpFoundation\Response|null
     */
    protected ?Response $response = null;

    /**
     * @inheritDoc
     */
    public static function setUpBeforeClass(): void
    {
        parent::setUpBeforeClass();

        /**
         * Loads the application's route collection from the configuration
         * file and stores it in a static property to avoid reloading
         * routes for every test method.
         */
        self::$routes = require CONFIG . '/routes.php';
    }

    /**
     * Executes a controller action for the given route.
     *
     * This method performs the following steps:
     * 1. Matches the route name to find the controller class and action method
     * 2. Validates that controller class and action method exist
     * 3. Instantiates the controller (which creates its own View instance)
     * 4. Creates a simulated Request object with route parameters substituted
     * 5. Injects the Request into the controller's view
     * 6. Calls the action method on the controller
     * 7. Renders the view and captures the Response object
     *
     * The resulting Response is stored in $this->response for assertions.
     *
     * @param string $route The route name as defined in routes.php (e.g., 'home', 'user_profile')
     * @param string $method The HTTP method to simulate (GET, POST, PUT, DELETE, etc.). Defaults to 'GET'.
     * @param array<string, mixed> $parameters Request parameters (query params for GET, body params for POST, etc.)
     * @param array<string, mixed> $routeParameters Route placeholder values (e.g., ['id' => 123] for `/users/{id}`)
     * @param array<string, string> $server Server and headers parameters ($_SERVER values)
     * @param string|null $content Raw request body content
     * @return void
     * @throws \RuntimeException If the route is not found, controller/action are invalid, or the class doesn't exist
     */
    protected function executeAction(
        string $route,
        string $method = 'GET',
        array $parameters = [],
        array $routeParameters = [],
        array $server = [],
        ?string $content = null,
    ): void {
        $routeInfo = self::$routes->get($route);

        if ($routeInfo === null) {
            $availableRoutes = implode(', ', array_keys(self::$routes->all()));
            throw new RuntimeException("Route `{$route}` not found. Available routes: {$availableRoutes}.");
        }

        // Validate controller and action defaults exist
        $controllerClass = $routeInfo->getDefault('_controller');
        $action = $routeInfo->getDefault('_action');

        if ($controllerClass === null || $action === null) {
            throw new RuntimeException(
                "Route `{$route}` is missing required defaults: `_controller` and/or `_action`."
            );
        }

        // Validate controller class exists and extends base Controller
        if (!is_string($controllerClass) || !class_exists($controllerClass)) {
            throw new RuntimeException("Controller class `{$controllerClass}` does not exist.");
        }

        if (!is_subclass_of($controllerClass, Controller::class)) {
            throw new RuntimeException("Controller `{$controllerClass}` must extend " . Controller::class . ".");
        }

        // Validate action method exists
        if (!is_string($action) || !method_exists($controllerClass, $action)) {
            throw new RuntimeException("Action `{$action}` does not exist in controller `{$controllerClass}`.");
        }

        /** @var \eLonePath\Controller\Controller $controller */
        $controller = new $controllerClass();

        // Replace route placeholders with actual values
        $path = $routeInfo->getPath();
        foreach ($routeParameters as $key => $value) {
            $path = str_replace("{{$key}}", (string)$value, $path);
        }

        // Create a simulated Request with proper parameters
        $request = Request::create($path, $method, $parameters, [], [], $server, $content);

        // Set route parameters in request attributes
        foreach ($routeParameters as $key => $value) {
            $request->attributes->set($key, $value);
        }

        // Set the controller in array format for View's autoDetectTemplate()
        $request->attributes->set('_controller', [$controllerClass, $action]);
        $controller->view->setRequest($request);

        // Execute the controller action
        $controller->$action();

        // Render view and capture Response
        $this->response = $controller->render();
    }

    /**
     * Asserts that a response has been set.
     *
     * This is a prerequisite check for all response assertion methods. If no response exists, it means
     *  `executeAction()` was not called.
     *
     * @return void
     * @throws \PHPUnit\Framework\AssertionFailedError If the response is null
     */
    protected function assertResponseExists(): void
    {
        $this->assertNotNull($this->response, 'Response has not been set. Did you call `executeAction()`?');
    }

    /**
     * Asserts that the response has a specific HTTP status code.
     *
     * @param int $expected The expected HTTP status code (e.g., 200, 404, 500)
     * @return void
     */
    protected function assertResponseStatusCode(int $expected): void
    {
        $this->assertResponseExists();
        $this->assertSame($expected, $this->response->getStatusCode());
    }

    /**
     * Asserts that the response is successful (2xx status code).
     *
     * @return void
     */
    protected function assertResponseIsSuccessful(): void
    {
        $this->assertResponseExists();
        $this->assertTrue($this->response->isSuccessful());
    }

    /**
     * Asserts that the response has a "404 Not Found" status code.
     *
     * @return void
     */
    protected function assertResponseIsNotFound(): void
    {
        $this->assertResponseStatusCode(404);
    }

    /**
     * Asserts that the response has a "500 Internal Server Error" status code.
     *
     * @return void
     */
    protected function assertResponseIsServerError(): void
    {
        $this->assertResponseStatusCode(500);
    }

    /**
     * Asserts that the response is a redirect (3xx status code).
     *
     * @return void
     */
    protected function assertResponseIsRedirect(): void
    {
        $this->assertResponseExists();
        $this->assertTrue($this->response->isRedirect());
    }

    /**
     * Asserts that the response is a redirect to a specific URL.
     *
     * @param string $expectedUrl The expected redirect URL
     * @return void
     */
    protected function assertRedirectsTo(string $expectedUrl): void
    {
        $this->assertResponseExists();
        $this->assertTrue($this->response->isRedirect(), 'Response is not a redirect.');

        $this->assertSame($expectedUrl, $this->response->headers->get('Location'));
    }

    /**
     * Asserts that the response content contains a specific string.
     *
     * Useful for checking if specific HTML elements, text, or data are present in the rendered output.
     *
     * @param string $needle The string to search for in the response content
     * @return void
     */
    protected function assertResponseContains(string $needle): void
    {
        $this->assertResponseExists();
        $this->assertStringContainsString($needle, $this->response->getContent());
    }

    /**
     * Asserts that the response content does not contain a specific string.
     *
     * Useful for verifying that sensitive data or unwanted content is not present in the rendered output.
     *
     * @param string $needle The string that should not appear in the response content
     * @return void
     */
    protected function assertResponseNotContains(string $needle): void
    {
        $this->assertResponseExists();
        $this->assertStringNotContainsString($needle, $this->response->getContent());
    }

    /**
     * Asserts that the response content matches a regular expression.
     *
     * Useful for complex pattern matching in the HTML output, such as validating specific HTML structures or data
     *  formats.
     *
     * @param string $pattern The regular expression pattern to match
     * @return void
     */
    protected function assertResponseMatchesRegex(string $pattern): void
    {
        $this->assertResponseExists();
        $this->assertMatchesRegularExpression($pattern, $this->response->getContent());
    }

    /**
     * Asserts that a specific HTTP header has an expected value.
     *
     * @param string $header The header name (e.g., `Content-Type`, `Cache-Control`)
     * @param string $expected The expected header value
     * @return void
     */
    protected function assertResponseHeader(string $header, string $expected): void
    {
        $this->assertResponseExists();
        $this->assertSame($expected, $this->response->headers->get($header));
    }
}
